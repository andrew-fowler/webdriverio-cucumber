'use strict';

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _getIterator = require('babel-runtime/core-js/get-iterator')['default'];

var _Promise = require('babel-runtime/core-js/promise')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _cucumber = require('cucumber');

var _cucumber2 = _interopRequireDefault(_cucumber);

var __$Getters__ = [];
var __$Setters__ = [];
var __$Resetters__ = [];

function __GetDependency__(name) {
    return __$Getters__[name]();
}

function __Rewire__(name, value) {
    __$Setters__[name](value);
}

function __ResetDependency__(name) {
    __$Resetters__[name]();
}

var __RewireAPI__ = {
    '__GetDependency__': __GetDependency__,
    '__get__': __GetDependency__,
    '__Rewire__': __Rewire__,
    '__set__': __Rewire__,
    '__ResetDependency__': __ResetDependency__
};
var Cucumber = _cucumber2['default'];

__$Getters__['Cucumber'] = function () {
    return Cucumber;
};

__$Setters__['Cucumber'] = function (value) {
    Cucumber = value;
};

__$Resetters__['Cucumber'] = function () {
    Cucumber = _cucumber2['default'];
};

var SETTLE_TIMEOUT = 5000;
var _SETTLE_TIMEOUT = SETTLE_TIMEOUT;

__$Getters__['SETTLE_TIMEOUT'] = function () {
    return SETTLE_TIMEOUT;
};

__$Setters__['SETTLE_TIMEOUT'] = function (value) {
    SETTLE_TIMEOUT = value;
};

__$Resetters__['SETTLE_TIMEOUT'] = function () {
    SETTLE_TIMEOUT = _SETTLE_TIMEOUT;
};

var CUCUMBER_EVENTS = ['handleBeforeFeatureEvent', 'handleAfterFeatureEvent', 'handleBeforeScenarioEvent', 'handleAfterScenarioEvent', 'handleBeforeStepEvent', 'handleStepResultEvent'];

/**
 * Custom Cucumber Reporter
 */
var _CUCUMBER_EVENTS = CUCUMBER_EVENTS;

__$Getters__['CUCUMBER_EVENTS'] = function () {
    return CUCUMBER_EVENTS;
};

__$Setters__['CUCUMBER_EVENTS'] = function (value) {
    CUCUMBER_EVENTS = value;
};

__$Resetters__['CUCUMBER_EVENTS'] = function () {
    CUCUMBER_EVENTS = _CUCUMBER_EVENTS;
};

var CucumberReporter = (function () {
    function CucumberReporter(BaseListener, options, cid, specs) {
        _classCallCheck(this, CucumberReporter);

        this.listener = BaseListener;
        this.capabilities = options.capabilities;
        this.options = options;
        this.cid = cid;
        this.specs = specs;
        this.failedCount = 0;

        this.sentMessages = 0; // number of messages sent to the parent
        this.receivedMessages = 0; // number of messages received by the parent

        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
            for (var _iterator = _getIterator(CUCUMBER_EVENTS), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var fnName = _step.value;

                this.listener[fnName] = CucumberReporter.prototype[fnName].bind(this);
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion && _iterator['return']) {
                    _iterator['return']();
                }
            } finally {
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
    }

    _createClass(CucumberReporter, [{
        key: 'handleBeforeFeatureEvent',
        value: function handleBeforeFeatureEvent(event, callback) {
            var feature = event.getUri ? event : event.getPayloadItem('feature');
            this.featureStart = new Date();
            this.runningFeature = feature;

            this.emit('suite:start', {
                uid: this.getUniqueIdentifier(feature),
                title: feature.getName(),
                type: 'suite',
                file: this.getUriOf(feature)
            });

            process.nextTick(callback);
        }
    }, {
        key: 'handleBeforeScenarioEvent',
        value: function handleBeforeScenarioEvent(event, callback) {
            var scenario = event.getUri ? event : event.getPayloadItem('scenario');
            this.runningScenario = scenario;
            this.scenarioStart = new Date();
            this.testStart = new Date();

            this.emit('suite:start', {
                uid: this.getUniqueIdentifier(scenario),
                title: scenario.getName(),
                parent: this.getUniqueIdentifier(this.runningFeature),
                type: 'suite',
                file: this.getUriOf(scenario)
            });

            process.nextTick(callback);
        }
    }, {
        key: 'handleBeforeStepEvent',
        value: function handleBeforeStepEvent(event, callback) {
            var step = event.getUri ? event : event.getPayloadItem('step');
            this.testStart = new Date();

            this.emit('test:start', {
                uid: this.getUniqueIdentifier(step),
                title: step.getName(),
                type: 'test',
                file: step.getUri(),
                parent: this.getUniqueIdentifier(this.runningScenario),
                duration: new Date() - this.testStart
            });

            process.nextTick(callback);
        }
    }, {
        key: 'handleStepResultEvent',
        value: function handleStepResultEvent(event, callback) {
            var stepResult = event.getStep ? event : event.getPayloadItem('stepResult');
            var step = stepResult.getStep();
            var e = 'undefined';

            switch (stepResult.getStatus()) {
                case Cucumber.Status.FAILED:
                case Cucumber.Status.UNDEFINED:
                    e = 'fail';
                    break;
                case Cucumber.Status.PASSED:
                    e = 'pass';
                    break;
                case Cucumber.Status.PENDING:
                case Cucumber.Status.SKIPPED:
                case Cucumber.Status.AMBIGUOUS:
                    e = 'pending';
            }
            var error = {};
            var stepTitle = step.getName() || step.getKeyword() || 'Undefined Step';

            /**
             * if step name is undefined we are dealing with a hook
             * don't report hooks if no error happened
             */
            if (!step.getName() && stepResult.getStatus() !== Cucumber.Status.FAILED) {
                return process.nextTick(callback);
            }

            if (stepResult.getStatus() === Cucumber.Status.UNDEFINED) {
                if (this.options.ignoreUndefinedDefinitions) {
                    /**
                     * mark test as pending
                     */
                    e = 'pending';
                    stepTitle += ' (undefined step)';
                } else {
                    /**
                     * mark test as failed
                     */
                    this.failedCount++;

                    error = {
                        message: 'Step "' + stepTitle + '" is not defined. You can ignore this error by setting\n                              cucumberOpts.ignoreUndefinedDefinitions as true.',
                        stack: step.getUri() + ':' + step.getLine()
                    };
                }
            } else if (stepResult.getStatus() === Cucumber.Status.FAILED) {
                /**
                 * cucumber failure exception can't get send to parent process
                 * for some reasons
                 */
                var err = stepResult.getFailureException();
                error = {
                    message: err.message,
                    stack: err.stack
                };
                this.failedCount++;
            } else if (stepResult.getStatus() === Cucumber.Status.AMBIGUOUS && this.options.failAmbiguousDefinitions) {
                e = 'fail';
                this.failedCount++;
                error = {
                    message: 'Step "' + stepTitle + '" is ambiguous. The following steps matched the step definition',
                    stack: stepResult.getAmbiguousStepDefinitions().map(function (step) {
                        return step.getPattern().toString() + ' in ' + step.getUri() + ':' + step.getLine();
                    }).join('\n')
                };
            }

            this.emit('test:' + e, {
                uid: this.getUniqueIdentifier(step),
                title: stepTitle.trim(),
                type: 'test',
                file: this.getUriOf(step),
                parent: this.getUniqueIdentifier(this.runningScenario),
                error: error,
                duration: new Date() - this.testStart
            });

            process.nextTick(callback);
        }
    }, {
        key: 'handleAfterScenarioEvent',
        value: function handleAfterScenarioEvent(event, callback) {
            var scenario = event.getUri ? event : event.getPayloadItem('scenario');
            this.emit('suite:end', {
                uid: this.getUniqueIdentifier(scenario),
                title: scenario.getName(),
                parent: this.getUniqueIdentifier(this.runningFeature),
                type: 'suite',
                file: this.getUriOf(scenario),
                duration: new Date() - this.scenarioStart
            });

            process.nextTick(callback);
        }
    }, {
        key: 'handleAfterFeatureEvent',
        value: function handleAfterFeatureEvent(event, callback) {
            var feature = event.getUri ? event : event.getPayloadItem('feature');
            this.emit('suite:end', {
                uid: this.getUniqueIdentifier(feature),
                title: feature.getName(),
                type: 'suite',
                file: this.getUriOf(feature),
                duration: new Date() - this.featureStart
            });

            process.nextTick(callback);
        }
    }, {
        key: 'emit',
        value: function emit(event, payload) {
            var _this = this;

            var message = {
                event: event,
                cid: this.cid,
                uid: payload.uid,
                title: payload.title,
                pending: payload.pending || false,
                parent: payload.parent || null,
                type: payload.type,
                file: payload.file,
                err: payload.error || {},
                duration: payload.duration,
                runner: {},
                specs: this.specs
            };

            message.runner[this.cid] = this.capabilities;

            this.send(message, null, {}, function () {
                return ++_this.receivedMessages;
            });
            this.sentMessages++;
        }
    }, {
        key: 'send',
        value: function send() {
            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
            }

            return process.send.apply(process, args);
        }

        /**
         * wait until all messages were sent to parent
         */
    }, {
        key: 'waitUntilSettled',
        value: function waitUntilSettled() {
            var _this2 = this;

            return new _Promise(function (resolve) {
                var start = new Date().getTime();
                var interval = setInterval(function () {
                    var now = new Date().getTime();

                    if (_this2.sentMessages !== _this2.receivedMessages && now - start < SETTLE_TIMEOUT) return;
                    clearInterval(interval);
                    resolve();
                }, 100);
            });
        }
    }, {
        key: 'getListener',
        value: function getListener() {
            return this.listener;
        }
    }, {
        key: 'getUriOf',
        value: function getUriOf(type) {
            if (!type || !type.getUri()) {
                return;
            }

            return type.getUri().replace(process.cwd(), '');
        }
    }, {
        key: 'getUniqueIdentifier',
        value: function getUniqueIdentifier(target) {
            return target.getName() + (target.getLine() || '');
        }
    }]);

    return CucumberReporter;
})();

var _defaultExport = CucumberReporter;

if (typeof _defaultExport === 'object' || typeof _defaultExport === 'function') {
    Object.defineProperty(_defaultExport, '__Rewire__', {
        'value': __Rewire__,
        'enumberable': false
    });
    Object.defineProperty(_defaultExport, '__set__', {
        'value': __Rewire__,
        'enumberable': false
    });
    Object.defineProperty(_defaultExport, '__ResetDependency__', {
        'value': __ResetDependency__,
        'enumberable': false
    });
    Object.defineProperty(_defaultExport, '__GetDependency__', {
        'value': __GetDependency__,
        'enumberable': false
    });
    Object.defineProperty(_defaultExport, '__get__', {
        'value': __GetDependency__,
        'enumberable': false
    });
    Object.defineProperty(_defaultExport, '__RewireAPI__', {
        'value': __RewireAPI__,
        'enumberable': false
    });
}

exports['default'] = _defaultExport;
exports.__GetDependency__ = __GetDependency__;
exports.__get__ = __GetDependency__;
exports.__Rewire__ = __Rewire__;
exports.__set__ = __Rewire__;
exports.__ResetDependency__ = __ResetDependency__;
exports.__RewireAPI__ = __RewireAPI__;
module.exports = exports['default'];
